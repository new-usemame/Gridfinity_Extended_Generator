import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';
import { BoxConfig, BaseplateConfig } from '../types/config.js';

const execAsync = promisify(exec);

export class OpenSCADService {
  private scadPath: string;
  private outputPath: string;

  constructor() {
    this.scadPath = path.join(process.cwd(), '..', 'scad');
    this.outputPath = path.join(process.cwd(), 'generated');
    
    // Ensure output directory exists
    if (!fs.existsSync(this.outputPath)) {
      fs.mkdirSync(this.outputPath, { recursive: true });
    }
  }

  // Generate Box STL
  async generateBox(config: BoxConfig): Promise<{ stlUrl: string; scadContent: string; filename: string }> {
    const scadContent = this.generateBoxScad(config);
    return this.renderScad(scadContent, 'box');
  }

  // Generate Baseplate STL
  async generateBaseplate(config: BaseplateConfig): Promise<{ stlUrl: string; scadContent: string; filename: string }> {
    const scadContent = this.generateBaseplateScad(config);
    return this.renderScad(scadContent, 'baseplate');
  }

  // Generate Box SCAD code
  generateBoxScad(config: BoxConfig): string {
    const gridUnit = 42; // Standard Gridfinity unit size in mm
    
    return `
// Gridfinity Box Generator
// Generated by Gridfinity Generator Web App

/* [Box Dimensions] */
width_units = ${config.width};           // Grid units
depth_units = ${config.depth};           // Grid units
height_units = ${config.height};         // Grid units

/* [Wall Settings] */
wall_thickness = ${config.wallThickness};
floor_thickness = ${config.floorThickness};

/* [Magnets] */
magnet_enabled = ${config.magnetEnabled};
magnet_diameter = ${config.magnetDiameter};
magnet_depth = ${config.magnetDepth};

/* [Screws] */
screw_enabled = ${config.screwEnabled};
screw_diameter = ${config.screwDiameter};

/* [Features] */
finger_slide = ${config.fingerSlide};
finger_slide_position = "${config.fingerSlidePosition}";
label_enabled = ${config.labelEnabled};
label_position = "${config.labelPosition}";
label_width_percent = ${config.labelWidth};

/* [Dividers] */
dividers_x = ${config.dividersX};
dividers_y = ${config.dividersY};

/* [Style] */
lip_style = "${config.lipStyle}";
base_style = "${config.baseStyle}";
corner_radius = ${config.cornerRadius};

// Constants
grid_unit = ${gridUnit};
base_height = 5;
lip_height = 4.75;
stacking_lip = 2.15;

// Calculated dimensions
box_width = width_units * grid_unit;
box_depth = depth_units * grid_unit;
box_height = height_units * 7 + base_height;

// Rounded rectangle module
module rounded_rect(w, d, h, r) {
    if (r > 0) {
        hull() {
            translate([r, r, 0]) cylinder(h=h, r=r, $fn=16);
            translate([w-r, r, 0]) cylinder(h=h, r=r, $fn=16);
            translate([r, d-r, 0]) cylinder(h=h, r=r, $fn=16);
            translate([w-r, d-r, 0]) cylinder(h=h, r=r, $fn=16);
        }
    } else {
        cube([w, d, h]);
    }
}

// Gridfinity base foot profile (creates the stacking interface)
// This profile is revolved to create the circular foot on each grid unit
module gridfinity_foot_profile() {
    // Standard Gridfinity foot profile dimensions
    foot_outer = 17.5;  // Outer radius of foot
    foot_inner = 15.5;  // Inner radius after step
    step_height = 0.8;  // Height of bottom step
    slope_height = 1.8; // Height of sloped section
    
    polygon(points=[
        [foot_inner, 0],
        [foot_outer, 0],
        [foot_outer, step_height],
        [foot_outer - 0.7, step_height],
        [foot_inner, step_height + slope_height],
        [foot_inner, base_height]
    ]);
}

// Single grid base with proper Gridfinity stacking foot
module grid_base(r=0) {
    difference() {
        union() {
            // Main base block (slightly inset from grid edges)
            translate([0.25, 0.25, 0])
            rounded_rect(grid_unit - 0.5, grid_unit - 0.5, base_height, r > 0 ? min(r, 2) : 0);
            
            // Gridfinity stacking foot (circular profile at center of each grid unit)
            translate([grid_unit/2, grid_unit/2, 0])
            rotate_extrude($fn=32)
            gridfinity_foot_profile();
        }
        
        // Hollow out the center of the foot (creates the distinctive Gridfinity look)
        translate([grid_unit/2, grid_unit/2, -0.1])
        cylinder(r=15.5, h=base_height - 1, $fn=32);
        
        // Magnet holes at corners
        if (magnet_enabled) {
            for (x = [4.8, grid_unit - 4.8])
            for (y = [4.8, grid_unit - 4.8])
            translate([x, y, -0.1])
            cylinder(d=magnet_diameter, h=magnet_depth + 0.1, $fn=16);
        }
        
        // Screw holes at corners
        if (screw_enabled) {
            for (x = [4.8, grid_unit - 4.8])
            for (y = [4.8, grid_unit - 4.8])
            translate([x, y, -0.1])
            cylinder(d=screw_diameter, h=base_height + 0.2, $fn=16);
        }
    }
}

// Main box body - starts at base_height so the feet are exposed underneath
module box_body() {
    translate([0, 0, base_height])
    difference() {
        // Outer shell (walls only, starting from top of base)
        rounded_rect(box_width, box_depth, box_height - base_height, corner_radius);
        
        // Inner cavity
        translate([wall_thickness, wall_thickness, floor_thickness])
        rounded_rect(
            box_width - wall_thickness*2, 
            box_depth - wall_thickness*2, 
            box_height - base_height, 
            corner_radius > 0 ? max(0, corner_radius - wall_thickness) : 0
        );
        
        // Stacking lip cutout at top
        if (lip_style != "none") {
            translate([0, 0, box_height - base_height - lip_height])
            difference() {
                cube([box_width, box_depth, lip_height + 1]);
                translate([stacking_lip, stacking_lip, 0])
                rounded_rect(
                    box_width - stacking_lip*2,
                    box_depth - stacking_lip*2,
                    lip_height + 1,
                    corner_radius > 0 ? max(0, corner_radius - stacking_lip) : 0
                );
            }
        }
    }
}

// Finger slide cutout
module finger_slide_cut() {
    if (finger_slide) {
        slide_width = box_width * 0.6;
        slide_depth = 15;
        slide_height = (box_height - base_height) * 0.5;
        
        if (finger_slide_position == "front") {
            translate([(box_width - slide_width)/2, -1, box_height - slide_height])
            rotate([-30, 0, 0])
            cube([slide_width, slide_depth, slide_height]);
        } else if (finger_slide_position == "back") {
            translate([(box_width - slide_width)/2, box_depth - slide_depth + 1, box_height - slide_height])
            rotate([30, 0, 0])
            cube([slide_width, slide_depth, slide_height]);
        }
    }
}

// Label tab
module label_tab() {
    if (label_enabled) {
        tab_width = (box_width - wall_thickness*2) * (label_width_percent / 100);
        tab_height = 12;
        tab_depth = 1.2;
        
        if (label_position == "front") {
            translate([(box_width - tab_width)/2, -0.1, box_height - tab_height - lip_height])
            cube([tab_width, tab_depth + 0.1, tab_height]);
        }
    }
}

// Dividers
module dividers() {
    if (dividers_x > 0 || dividers_y > 0) {
        inner_width = box_width - wall_thickness*2;
        inner_depth = box_depth - wall_thickness*2;
        divider_height = box_height - base_height - floor_thickness - lip_height;
        
        // X dividers
        if (dividers_x > 0) {
            spacing_x = inner_width / (dividers_x + 1);
            for (i = [1:dividers_x]) {
                translate([wall_thickness + i * spacing_x - 0.6, wall_thickness, base_height + floor_thickness])
                cube([1.2, inner_depth, divider_height]);
            }
        }
        
        // Y dividers
        if (dividers_y > 0) {
            spacing_y = inner_depth / (dividers_y + 1);
            for (i = [1:dividers_y]) {
                translate([wall_thickness, wall_thickness + i * spacing_y - 0.6, base_height + floor_thickness])
                cube([inner_width, 1.2, divider_height]);
            }
        }
    }
}

// Complete box
module gridfinity_box() {
    union() {
        // Base grid
        for (x = [0:width_units-1])
        for (y = [0:depth_units-1])
        translate([x * grid_unit, y * grid_unit, 0])
        grid_base(corner_radius);
        
        // Box body
        difference() {
            union() {
                box_body();
                label_tab();
            }
            finger_slide_cut();
        }
        
        // Dividers
        dividers();
    }
}

// Render
gridfinity_box();
`;
  }

  // Generate Baseplate SCAD code
  generateBaseplateScad(config: BaseplateConfig): string {
    const gridUnit = 42;
    
    return `
// Gridfinity Baseplate Generator
// Generated by Gridfinity Generator Web App

/* [Baseplate Dimensions] */
width_units = ${config.width};           // Grid units
depth_units = ${config.depth};           // Grid units

/* [Style] */
style = "${config.style}";               // default, magnet, weighted, screw
lid_option = "${config.lidOption}";      // none, flat, halfPitch

/* [Magnets/Screws] */
magnet_diameter = ${config.magnetDiameter};
magnet_depth = ${config.magnetDepth};
screw_diameter = ${config.screwDiameter};

/* [Corner Rounding] */
corner_radius = ${config.cornerRadius};
corner_segments = ${config.cornerSegments};

// Constants
grid_unit = ${gridUnit};
plate_height = 4.65;
socket_depth = 2.15;

// Calculated dimensions
plate_width = width_units * grid_unit;
plate_depth = depth_units * grid_unit;

// Rounded rectangle module with configurable segments
module rounded_rect(w, d, h, r, fn=16) {
    if (r > 0) {
        hull() {
            translate([r, r, 0]) cylinder(h=h, r=r, $fn=fn);
            translate([w-r, r, 0]) cylinder(h=h, r=r, $fn=fn);
            translate([r, d-r, 0]) cylinder(h=h, r=r, $fn=fn);
            translate([w-r, d-r, 0]) cylinder(h=h, r=r, $fn=fn);
        }
    } else {
        cube([w, d, h]);
    }
}

// Socket profile for bin connection
module socket_profile() {
    polygon(points=[
        [0, 0],
        [2.6, 0],
        [2.6, 0.7],
        [1.9, 0.7],
        [0.7, 1.9],
        [0.7, socket_depth],
        [0, socket_depth]
    ]);
}

// Single grid socket
module grid_socket() {
    translate([grid_unit/2, grid_unit/2, plate_height - socket_depth])
    rotate_extrude($fn=24)
    translate([grid_unit/2 - 2.6, 0, 0])
    socket_profile();
}

// Magnet hole
module magnet_hole() {
    cylinder(d=magnet_diameter, h=magnet_depth + 0.1, $fn=16);
}

// Screw hole
module screw_hole() {
    cylinder(d=screw_diameter, h=plate_height + 0.2, $fn=16);
}

// Weighted base cutout
module weight_cutout() {
    hull() {
        translate([8, 8, -0.1]) cylinder(d=8, h=plate_height - 1, $fn=16);
        translate([grid_unit-8, 8, -0.1]) cylinder(d=8, h=plate_height - 1, $fn=16);
        translate([8, grid_unit-8, -0.1]) cylinder(d=8, h=plate_height - 1, $fn=16);
        translate([grid_unit-8, grid_unit-8, -0.1]) cylinder(d=8, h=plate_height - 1, $fn=16);
    }
}

// Single grid cell
module grid_cell(x_pos, y_pos, is_corner_tl, is_corner_tr, is_corner_bl, is_corner_br) {
    cell_corner_r = corner_radius;
    
    translate([x_pos * grid_unit, y_pos * grid_unit, 0]) {
        difference() {
            // Base plate cell
            cube([grid_unit, grid_unit, plate_height]);
            
            // Socket cutout
            grid_socket();
            
            // Style-specific cutouts
            if (style == "magnet") {
                for (mx = [4.8, grid_unit - 4.8])
                for (my = [4.8, grid_unit - 4.8])
                translate([mx, my, -0.1])
                magnet_hole();
            }
            
            if (style == "screw") {
                for (sx = [4.8, grid_unit - 4.8])
                for (sy = [4.8, grid_unit - 4.8])
                translate([sx, sy, -0.1])
                screw_hole();
            }
            
            if (style == "weighted") {
                weight_cutout();
            }
        }
    }
}

// Corner rounding for outer edges
module corner_round_cut(r, h) {
    if (r > 0) {
        difference() {
            cube([r + 0.1, r + 0.1, h + 0.2]);
            translate([r, r, -0.1])
            cylinder(r=r, h=h + 0.4, $fn=16);
        }
    }
}

// Main baseplate
module gridfinity_baseplate() {
    difference() {
        union() {
            // Generate all grid cells
            for (x = [0:width_units-1])
            for (y = [0:depth_units-1])
            grid_cell(
                x, y,
                x == 0 && y == depth_units-1,
                x == width_units-1 && y == depth_units-1,
                x == 0 && y == 0,
                x == width_units-1 && y == 0
            );
        }
        
        // Round outer corners if enabled
        if (corner_radius > 0) {
            // Bottom-left corner
            translate([-0.1, -0.1, -0.1])
            corner_round_cut(corner_radius, plate_height);
            
            // Bottom-right corner
            translate([plate_width + 0.1, -0.1, -0.1])
            rotate([0, 0, 90])
            corner_round_cut(corner_radius, plate_height);
            
            // Top-left corner
            translate([-0.1, plate_depth + 0.1, -0.1])
            rotate([0, 0, -90])
            corner_round_cut(corner_radius, plate_height);
            
            // Top-right corner
            translate([plate_width + 0.1, plate_depth + 0.1, -0.1])
            rotate([0, 0, 180])
            corner_round_cut(corner_radius, plate_height);
        }
    }
    
    // Lid plate option
    if (lid_option == "flat") {
        translate([0, 0, plate_height])
        rounded_rect(plate_width, plate_depth, 1.2, corner_radius, corner_segments);
    }
    
    if (lid_option == "halfPitch") {
        translate([0, 0, plate_height])
        difference() {
            rounded_rect(plate_width, plate_depth, 2.5, corner_radius, 16);
            
            // Half-pitch grid pattern
            for (x = [0:width_units*2-1])
            for (y = [0:depth_units*2-1])
            translate([x * grid_unit/2 + grid_unit/4, y * grid_unit/2 + grid_unit/4, 1.2])
            cylinder(d=grid_unit/2 - 2, h=2, $fn=16);
        }
    }
}

// Render
gridfinity_baseplate();
`;
  }

  // Render SCAD to STL
  private async renderScad(scadContent: string, prefix: string): Promise<{ stlUrl: string; scadContent: string; filename: string }> {
    const id = uuidv4().substring(0, 8);
    const scadFilename = `${prefix}_${id}.scad`;
    const stlFilename = `${prefix}_${id}.stl`;
    const scadFilePath = path.join(this.outputPath, scadFilename);
    const stlFilePath = path.join(this.outputPath, stlFilename);

    // Write SCAD file
    fs.writeFileSync(scadFilePath, scadContent);

    try {
      // Run OpenSCAD to generate STL
      const openscadCmd = process.env.OPENSCAD_PATH || 'openscad';
      const cmd = `${openscadCmd} -o "${stlFilePath}" "${scadFilePath}"`;
      
      await execAsync(cmd, { timeout: 120000 }); // 2 minute timeout

      // Clean up SCAD file
      fs.unlinkSync(scadFilePath);

      return {
        stlUrl: `/files/${stlFilename}`,
        scadContent,
        filename: stlFilename
      };
    } catch (error) {
      // Clean up on error
      if (fs.existsSync(scadFilePath)) {
        fs.unlinkSync(scadFilePath);
      }
      throw error;
    }
  }

  // Clean up old generated files (call periodically)
  cleanupOldFiles(maxAgeMs: number = 3600000): void {
    const now = Date.now();
    const files = fs.readdirSync(this.outputPath);

    for (const file of files) {
      const filePath = path.join(this.outputPath, file);
      const stats = fs.statSync(filePath);
      
      if (now - stats.mtimeMs > maxAgeMs) {
        fs.unlinkSync(filePath);
      }
    }
  }
}
